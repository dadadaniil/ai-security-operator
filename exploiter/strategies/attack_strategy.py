from abc import ABC, abstractmethod
from typing import Dict
import logging
from datetime import datetime
import socket # For DNS resolution diagnostic

from core.step_execution_result import StepExecutionResult
from core.base_exploit_instructions import BaseExploitInstructions, MetasploitInstructions, FuzzerInstructions
from core.msf_manager import msf_manager, ConnectionError as MSFConnectionError

logger = logging.getLogger(__name__)

class IAttackStrategy(ABC):
    @abstractmethod
    def execute(self, step_id: str, instructions: BaseExploitInstructions, expected_criteria: Dict) -> StepExecutionResult:
        pass

class MetasploitAttackStrategy(IAttackStrategy):
    def execute(self, step_id: str, instructions: MetasploitInstructions, expected_criteria: Dict) -> StepExecutionResult:
        start_time = datetime.now()
        raw_request_details = {
            "module_name": instructions.module_name,
            "rhosts": instructions.rhosts,
            # "rport" is no longer a direct field, would be in module_options if needed
            "module_options": instructions.module_options
        }

        logger.info(f"Executing Metasploit step {step_id} with module {instructions.module_name} on target {instructions.rhosts}")

        try:
            client = msf_manager.get_client()
            if not client:
                raise MSFConnectionError("Metasploit client not available or not connected.")

            module_path_parts = instructions.module_name.split('/', 1)
            if len(module_path_parts) < 2:
                raise ValueError(f"Invalid module_name format: '{instructions.module_name}'. Expected type/path (e.g., exploit/windows/smb/ms17_010).")
            
            module_type, module_name_only = module_path_parts[0].lower(), module_path_parts[1]
            
            valid_module_types = ["exploit", "auxiliary", "post", "payload", "encoder", "nop"]
            if module_type not in valid_module_types:
                raise ValueError(f"Invalid module type '{module_type}' derived from module_name: '{instructions.module_name}'. Supported types: {valid_module_types}")

            logger.debug(f"Using module type: {module_type}, name: {module_name_only}")
            module_instance = client.modules.use(module_type, module_name_only)

            # --- RHOSTS Handling with diagnostic DNS resolution ---
            rhosts_value_for_msf = instructions.rhosts # Start with the original value
            try:
                # Check if it's already a valid IP string
                socket.inet_aton(instructions.rhosts)
                logger.info(f"RHOSTS value '{instructions.rhosts}' is already an IP address. Using it directly.")
                rhosts_value_for_msf = instructions.rhosts
            except socket.error:
                logger.info(f"RHOSTS value '{instructions.rhosts}' is not an IP. Attempting DNS resolution...")
                try:
                    resolved_ip = socket.gethostbyname(instructions.rhosts)
                    logger.info(f"Successfully resolved '{instructions.rhosts}' to '{resolved_ip}'. Using resolved IP for Metasploit RHOSTS option.")
                    rhosts_value_for_msf = resolved_ip # USE THE RESOLVED IP
                except socket.gaierror:
                    logger.warning(f"Failed to resolve RHOSTS value '{instructions.rhosts}' via DNS. Passing original value '{instructions.rhosts}' to Metasploit. This may fail validation.")
                    rhosts_value_for_msf = instructions.rhosts # Fallback to original if resolution fails
            
            try:
                logger.debug(f"Attempting to set RHOSTS on Metasploit module to: '{rhosts_value_for_msf}'")
                module_instance['RHOSTS'] = rhosts_value_for_msf
            except Exception as e:
                logger.error(f"Failed to set RHOSTS='{rhosts_value_for_msf}' on module {instructions.module_name}. Error: {e}")
                raise ValueError(f"Failed to set RHOSTS on module {instructions.module_name}: {e}")
            # --- End RHOSTS Handling ---

            # Set other module options from instructions.module_options
            if instructions.module_options:
                for key, value in instructions.module_options.items():
                    option_key_upper = key.upper()
                    # PAYLOAD is a special case for exploits, handled during execution call
                    if option_key_upper == 'PAYLOAD' and module_type == 'exploit':
                        continue
                    try:
                        logger.debug(f"Setting module option: {option_key_upper} = {value} (type: {type(value)})")
                        module_instance[option_key_upper] = value
                    except Exception as option_set_error:
                        logger.error(f"Failed to set option {option_key_upper}={value} for module {instructions.module_name}. Error: {option_set_error}")
                        raise ValueError(f"Failed to set option {option_key_upper} on module {instructions.module_name}: {option_set_error}")
            
            logger.debug(f"Final module options before execution: {module_instance.options}")

            job_info = {}
            execution_message = ""

            if module_type == 'exploit':
                payload_to_use = instructions.module_options.get("PAYLOAD")
                if not payload_to_use:
                    raise ValueError(f"Payload not specified in module_options for exploit module '{instructions.module_name}'. Please set 'PAYLOAD'.")
                logger.info(f"Executing exploit with payload: {payload_to_use}")
                # The actual execution for an exploit. This starts a job.
                job_info = module_instance.execute(payload=payload_to_use)
                execution_message = f"Exploit job started. Job Info: {job_info}"
            else: # For auxiliary, post, etc.
                logger.info(f"Executing {module_type} module.")
                # Execution for non-exploit modules. This might return direct output or a job.
                job_info = module_instance.execute() 
                execution_message = f"{module_type.capitalize()} module executed. Result/Job Info: {job_info}"

            # TODO: Implement robust job and session tracking.
            # For now, a successfully dispatched job is considered a preliminary success.
            # Real success depends on job completion, session creation, and expected_criteria.
            
            current_status = "success" # Simplified: assume dispatch success means overall step success for now.
            if module_type == 'exploit' and not job_info.get('job_id'):
                current_status = "error"
                execution_message = f"Exploit {instructions.module_name} executed but did not return a job ID. Result: {job_info}"


            logger.info(f"Metasploit step {step_id} finished. Status: {current_status}, Message: {execution_message}")
            
            return StepExecutionResult(
                step_id=step_id,
                tool_used="metasploit",
                status=current_status,
                message=execution_message,
                raw_request=raw_request_details,
                raw_response=job_info, 
                extracted_data={}, # TODO: Populate with parsed output based on expected_criteria
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )

        except MSFConnectionError as e:
            logger.error(f"MSF ConnectionError in step {step_id} for {instructions.module_name}: {e}")
            return StepExecutionResult(
                step_id=step_id, tool_used="metasploit", status="error",
                message=f"Metasploit connection error: {str(e)}",
                raw_request=raw_request_details, raw_response={"error": str(e)}, extracted_data={},
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000)
        except ValueError as e: # For issues like bad module name format, missing payload
            logger.error(f"ValueError in step {step_id} for {instructions.module_name}: {e}")
            return StepExecutionResult(
                step_id=step_id, tool_used="metasploit", status="error",
                message=str(e),
                raw_request=raw_request_details, raw_response={"error": str(e)}, extracted_data={},
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000)
        except Exception as e:
            # This can catch various errors from pymsfrpc, like module not found, option validation, etc.
            logger.error(f"General error in Metasploit step {step_id} for {instructions.module_name}: {e}", exc_info=True)
            return StepExecutionResult(
                step_id=step_id, tool_used="metasploit", status="error",
                message=f"Error executing Metasploit module: {str(e)}",
                raw_request=raw_request_details, raw_response={"error": str(e)}, extracted_data={},
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000)

class FuzzerAttackStrategy(IAttackStrategy):
    def execute(self, step_id: str, instructions: FuzzerInstructions, expected_criteria: Dict) -> StepExecutionResult:
        # Implement Fuzzer execution logic here
        pass

class CustomHttpAttackStrategy(IAttackStrategy):
    def execute(self, step_id: str, instructions: BaseExploitInstructions, expected_criteria: Dict) -> StepExecutionResult:
        # Implement Custom HTTP execution logic here
        pass 