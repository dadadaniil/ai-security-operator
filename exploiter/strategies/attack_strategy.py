from abc import ABC, abstractmethod
from typing import Dict
import logging
from datetime import datetime

from core.step_execution_result import StepExecutionResult
from core.base_exploit_instructions import BaseExploitInstructions, MetasploitInstructions, FuzzerInstructions
from core.msf_manager import msf_manager, ConnectionError as MSFConnectionError

logger = logging.getLogger(__name__)

class IAttackStrategy(ABC):
    @abstractmethod
    def execute(self, step_id: str, instructions: BaseExploitInstructions, expected_criteria: Dict) -> StepExecutionResult:
        pass

class MetasploitAttackStrategy(IAttackStrategy):
    def execute(self, step_id: str, instructions: MetasploitInstructions, expected_criteria: Dict) -> StepExecutionResult:
        start_time = datetime.now()
        raw_request_details = {
            "module_name": instructions.module_name,
            "rhosts": instructions.rhosts,
            "rport": instructions.rport,
            "additional_options": instructions.additional_options
        }

        logger.info(f"Executing Metasploit step {step_id} with module {instructions.module_name} on {instructions.rhosts}")

        try:
            client = msf_manager.get_client()
            if not client:
                raise MSFConnectionError("Metasploit client not available or not connected.")

            # Parse module_name to get type (exploit, auxiliary, etc.) and actual path
            # Assumes format like "exploit/windows/smb/ms17_010_eternalblue"
            # TODO: Consider adding a dedicated 'module_type' field to MetasploitInstructions for clarity.
            module_path_parts = instructions.module_name.split('/', 1)
            if len(module_path_parts) < 2:
                raise ValueError(f"Invalid module_name format: '{instructions.module_name}'. Expected type/path (e.g., exploit/windows/smb/ms17_010).")
            
            module_type, module_name_only = module_path_parts[0].lower(), module_path_parts[1]
            
            valid_module_types = ["exploit", "auxiliary", "post", "payload", "encoder", "nop"]
            if module_type not in valid_module_types:
                raise ValueError(f"Invalid module type '{module_type}' derived from module_name: '{instructions.module_name}'. Supported types: {valid_module_types}")

            logger.debug(f"Using module type: {module_type}, name: {module_name_only}")
            module_instance = client.modules.use(module_type, module_name_only)

            # Set common options
            module_instance['RHOSTS'] = instructions.rhosts
            if instructions.rport is not None:
                module_instance['RPORT'] = instructions.rport
            
            # Set additional options from instructions
            for key, value in instructions.additional_options.items():
                # PAYLOAD is a special case for exploits, handled during execution call
                if key.upper() == 'PAYLOAD' and module_type == 'exploit':
                    continue 
                module_instance[key] = value
            
            logger.debug(f"Module options set: {module_instance.options}")

            job_info = {}
            execution_message = ""

            if module_type == 'exploit':
                payload_to_use = instructions.additional_options.get("PAYLOAD")
                if not payload_to_use:
                    raise ValueError(f"Payload not specified in additional_options for exploit module '{instructions.module_name}'. Please set 'PAYLOAD'.")
                logger.info(f"Executing exploit with payload: {payload_to_use}")
                # The actual execution for an exploit. This starts a job.
                job_info = module_instance.execute(payload=payload_to_use)
                execution_message = f"Exploit job started. Job Info: {job_info}"
            else: # For auxiliary, post, etc.
                logger.info(f"Executing {module_type} module.")
                # Execution for non-exploit modules. This might return direct output or a job.
                job_info = module_instance.execute() 
                execution_message = f"{module_type.capitalize()} module executed. Result/Job Info: {job_info}"

            # TODO: Implement robust job and session tracking.
            # For now, a successfully dispatched job is considered a preliminary success.
            # Real success depends on job completion, session creation, and expected_criteria.
            
            current_status = "success" # Simplified: assume dispatch success means overall step success for now.
            if module_type == 'exploit' and not job_info.get('job_id'):
                current_status = "error"
                execution_message = f"Exploit {instructions.module_name} executed but did not return a job ID. Result: {job_info}"


            logger.info(f"Metasploit step {step_id} finished. Status: {current_status}, Message: {execution_message}")
            
            return StepExecutionResult(
                step_id=step_id,
                tool_used="metasploit",
                status=current_status,
                message=execution_message,
                raw_request=raw_request_details,
                raw_response=job_info, 
                extracted_data={}, # TODO: Populate with parsed output based on expected_criteria
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )

        except MSFConnectionError as e:
            logger.error(f"MSF ConnectionError in step {step_id} for {instructions.module_name}: {e}")
            return StepExecutionResult(
                step_id=step_id, tool_used="metasploit", status="error",
                message=f"Metasploit connection error: {str(e)}",
                raw_request=raw_request_details, raw_response={"error": str(e)}, extracted_data={},
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000)
        except ValueError as e: # For issues like bad module name format, missing payload
            logger.error(f"ValueError in step {step_id} for {instructions.module_name}: {e}")
            return StepExecutionResult(
                step_id=step_id, tool_used="metasploit", status="error",
                message=str(e),
                raw_request=raw_request_details, raw_response={"error": str(e)}, extracted_data={},
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000)
        except Exception as e:
            # This can catch various errors from pymsfrpc, like module not found, option validation, etc.
            logger.error(f"General error in Metasploit step {step_id} for {instructions.module_name}: {e}", exc_info=True)
            return StepExecutionResult(
                step_id=step_id, tool_used="metasploit", status="error",
                message=f"Error executing Metasploit module: {str(e)}",
                raw_request=raw_request_details, raw_response={"error": str(e)}, extracted_data={},
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000)

class FuzzerAttackStrategy(IAttackStrategy):
    def execute(self, step_id: str, instructions: FuzzerInstructions, expected_criteria: Dict) -> StepExecutionResult:
        # Implement Fuzzer execution logic here
        pass

class CustomHttpAttackStrategy(IAttackStrategy):
    def execute(self, step_id: str, instructions: BaseExploitInstructions, expected_criteria: Dict) -> StepExecutionResult:
        # Implement Custom HTTP execution logic here
        pass 