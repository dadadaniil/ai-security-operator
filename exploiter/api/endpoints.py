from fastapi import APIRouter, HTTPException, Depends, Query, Path
from fastapi.responses import JSONResponse
from typing import List, Dict, Any, Optional, Union
from pydantic import BaseModel, Field, validator
import logging
import socket # Added for network diagnostics
import os # Added to get TARGET_HOST from environment

from services.scanner import scanner_service
from core.msf_manager import msf_manager, ConnectionError
from core.attack_plan import AttackPlan
from core.attack_plan_execution_report import AttackPlanExecutionReport
from core.attack_step import AttackStep
from core.base_exploit_instructions import BaseExploitInstructions, MetasploitInstructions, FuzzerInstructions
from services.attack_orchestrate import AttackOrchestrate
from utils.attack_strategy_factory import AttackStrategyFactory
from strategies.attack_strategy import MetasploitAttackStrategy, FuzzerAttackStrategy, CustomHttpAttackStrategy

# Configure logging
logger = logging.getLogger("api_endpoints")

# Create router
router = APIRouter()

# Request/Response models
class StatusResponse(BaseModel):
    status: str
    version: Dict[str, str] = {}
    connected: bool

class ModuleListRequest(BaseModel):
    module_type: str = Field(default="exploits", description="Type of module to list")
    limit: int = Field(default=10, description="Maximum number of modules to return")

class ScanRequest(BaseModel):
    target: str = Field(..., description="Target host to scan")
    ports: str = Field(default="80,443,22,21", description="Comma-separated list of ports to scan")
    
    @validator('target')
    def validate_target(cls, v):
        if not v:
            raise ValueError("Target host cannot be empty")
        return v

class ModuleInfoRequest(BaseModel):
    module_type: str = Field(..., description="Type of module")
    module_name: str = Field(..., description="Name of the module")

class ConnectivityTestResponse(BaseModel):
    target_host_reachable: bool
    target_host_error: Optional[str] = None
    msf_service_available: bool
    msf_service_error: Optional[str] = None
    msf_rpc_connection_ok: bool
    msf_rpc_error: Optional[str] = None
    msf_version: Optional[Dict[str, str]] = None

# Health endpoint
@router.get("/health", response_model=StatusResponse, tags=["system"])
async def health():
    """Check the API and Metasploit connection status"""
    try:
        # Try to get version info from Metasploit
        client = msf_manager.get_client()
        version = client.core.version
        
        return {
            "status": "ok",
            "version": version,
            "connected": msf_manager.connected
        }
    except ConnectionError as e:
        logger.error(f"Health check failed: {str(e)}")
        return {
            "status": "error",
            "version": {},
            "connected": False
        }
    except Exception as e:
        logger.error(f"Unexpected error in health check: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

# Diagnostic endpoint
@router.get("/diag", response_model=ConnectivityTestResponse, tags=["system"])
async def check_connectivity(
    target_host_override: Optional[str] = Query(None, description="Optional target host to test, defaults to TARGET_HOST env var"),
    target_port: int = Query(8080, description="Target port to test")
):
    """
    Diagnose connectivity to the target application and Metasploit.
    """
    target_host_reachable = False
    target_host_error = None
    msf_service_available = False
    msf_service_error = None
    msf_rpc_connection_ok = False
    msf_rpc_error = None
    msf_version_info = None

    # Determine target host
    actual_target_host = target_host_override if target_host_override else os.getenv("TARGET_HOST")

    if not actual_target_host:
        target_host_error = "TARGET_HOST environment variable is not set and no override was provided."
    else:
        # 1. Test connectivity to the target host and port
        try:
            logger.info(f"Attempting to connect to target: {actual_target_host}:{target_port}")
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)  # 5-second timeout
            result = sock.connect_ex((actual_target_host, target_port))
            if result == 0:
                target_host_reachable = True
                logger.info(f"Successfully connected to {actual_target_host}:{target_port}")
            else:
                target_host_error = f"Connection to {actual_target_host}:{target_port} failed. Error code: {result}, {os.strerror(result)}"
                logger.warning(target_host_error)
            sock.close()
        except socket.gaierror as e: # Address-related errors (e.g. DNS resolution failure)
            target_host_error = f"Address-related error connecting to {actual_target_host}:{target_port}: {str(e)}"
            logger.error(target_host_error)
        except socket.error as e: # Other socket errors
            target_host_error = f"Socket error connecting to {actual_target_host}:{target_port}: {str(e)}"
            logger.error(target_host_error)
        except Exception as e:
            target_host_error = f"Unexpected error connecting to {actual_target_host}:{target_port}: {str(e)}"
            logger.error(target_host_error)

    # 2. Test if Metasploit service is listening (socket level)
    try:
        logger.info(f"Attempting to connect to Metasploit service: {msf_manager.host}:{msf_manager.port}")
        msf_service_available = msf_manager.wait_for_service(max_retries=1, delay=1) # Quick check
        if not msf_service_available:
            msf_service_error = f"Metasploit service at {msf_manager.host}:{msf_manager.port} is not responding."
            logger.warning(msf_service_error)
        else:
            logger.info(f"Metasploit service at {msf_manager.host}:{msf_manager.port} is responding.")
    except Exception as e:
        msf_service_error = f"Error checking Metasploit service availability: {str(e)}"
        logger.error(msf_service_error)


    # 3. Test Metasploit RPC connection and get version (if service seems available)
    if msf_service_available:
        try:
            logger.info("Attempting to connect to Metasploit RPC...")
            client = msf_manager.connect(force_reconnect=True) # Force a new connection attempt
            msf_version_info = client.core.version
            msf_rpc_connection_ok = True
            logger.info(f"Successfully connected to Metasploit RPC. Version: {msf_version_info}")
        except ConnectionError as e:
            msf_rpc_error = f"Metasploit RPC connection failed: {str(e)}"
            logger.error(msf_rpc_error)
        except Exception as e:
            msf_rpc_error = f"Unexpected error connecting to Metasploit RPC: {str(e)}"
            logger.error(msf_rpc_error)
    else:
        msf_rpc_error = "Skipped RPC connection test as MSF service is not available."
        logger.warning(msf_rpc_error)


    return ConnectivityTestResponse(
        target_host_reachable=target_host_reachable,
        target_host_error=target_host_error,
        msf_service_available=msf_service_available,
        msf_service_error=msf_service_error,
        msf_rpc_connection_ok=msf_rpc_connection_ok,
        msf_rpc_error=msf_rpc_error,
        msf_version=msf_version_info,
    )

# Module listing endpoint
@router.get("/modules/{module_type}", tags=["modules"])
async def list_modules(
    module_type: str = Path(..., description="Type of module to list"),
    limit: int = Query(10, description="Maximum number of modules to return")
):
    """List available modules of the specified type"""
    try:
        modules = scanner_service.get_available_modules(module_type=module_type, limit=limit)
        return {
            "module_type": module_type,
            "limit": limit,
            "count": len(modules),
            "modules": modules
        }
    except Exception as e:
        logger.error(f"Error listing modules: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error listing modules: {str(e)}")

# Module info endpoint
@router.get("/modules/{module_type}/{module_name}", tags=["modules"])
async def get_module_info(
    module_type: str = Path(..., description="Type of module"),
    module_name: str = Path(..., description="Name of the module")
):
    """Get detailed information about a specific module"""
    try:
        info = scanner_service.get_module_info(module_type=module_type, module_name=module_name)
        return info
    except Exception as e:
        logger.error(f"Error getting module info: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting module info: {str(e)}")

# Port scanning endpoint
@router.post("/scan", tags=["scanning"])
async def scan_target(scan_request: ScanRequest):
    """Scan a target host for open ports"""
    try:
        result = scanner_service.run_port_scan(
            target_host=scan_request.target,
            ports=scan_request.ports
        )
        return result
    except Exception as e:
        logger.error(f"Error running port scan: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error running port scan: {str(e)}")

# Metasploit version endpoint
@router.get("/version", tags=["system"])
async def get_version():
    """Get Metasploit version information"""
    try:
        version = scanner_service.get_metasploit_version()
        return version
    except ConnectionError as e:
        logger.error(f"Connection error: {str(e)}")
        raise HTTPException(status_code=503, detail="Metasploit connection unavailable")
    except Exception as e:
        logger.error(f"Error getting version: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting version: {str(e)}")

# New Attack Execution Endpoint
@router.post("/attack/execute", response_model=AttackPlanExecutionReport, tags=["attack"])
async def execute_attack_plan(attack_plan: AttackPlan):
    """
    Receives an attack plan, executes it using the AttackOrchestrate service,
    and returns the execution report.
    """
    logger.info(f"Received attack plan: {attack_plan.plan_id} for target: {attack_plan.target_info}")
    try:
        # 1. Create and configure AttackStrategyFactory
        strategy_factory = AttackStrategyFactory()
        # These tool names must match 'tool_to_use' in AttackStep
        strategy_factory.register_strategy("metasploit", MetasploitAttackStrategy)
        strategy_factory.register_strategy("fuzzer", FuzzerAttackStrategy)
        strategy_factory.register_strategy("custom_http", CustomHttpAttackStrategy)
        # Add other strategies as needed

        # 2. Create AttackOrchestrate instance
        attack_orchestrator = AttackOrchestrate(strategy_factory=strategy_factory)

        # 3. Execute the plan
        logger.info(f"Executing attack plan {attack_plan.plan_id}...")
        report = attack_orchestrator.execute_plan(plan=attack_plan)
        logger.info(f"Attack plan {attack_plan.plan_id} execution finished. Status: {report.overall_status}")
        
        return report

    except ValueError as ve:
        logger.error(f"ValueError during attack execution for plan {attack_plan.plan_id}: {str(ve)}")
        raise HTTPException(status_code=400, detail=str(ve)) # e.g., "No strategy registered for tool"
    except ConnectionError as ce: # Assuming msf_manager could be used by strategies
        logger.error(f"Metasploit connection error during attack plan {attack_plan.plan_id}: {str(ce)}")
        raise HTTPException(status_code=503, detail=f"Metasploit connection error: {str(ce)}")
    except Exception as e:
        logger.error(f"Unexpected error during attack execution for plan {attack_plan.plan_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}") 