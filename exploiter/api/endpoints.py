from fastapi import APIRouter, HTTPException, Depends, Query, Path
from fastapi.responses import JSONResponse
from typing import List, Dict, Any, Optional, Union
from pydantic import BaseModel, Field, validator
import logging

from services.scanner import scanner_service
from core.msf_manager import msf_manager, ConnectionError
from core.attack_plan import AttackPlan
from core.attack_plan_execution_report import AttackPlanExecutionReport
from core.attack_step import AttackStep
from core.base_exploit_instructions import BaseExploitInstructions, MetasploitInstructions, FuzzerInstructions
from services.attack_orchestrate import AttackOrchestrate
from utils.attack_strategy_factory import AttackStrategyFactory
from strategies.attack_strategy import MetasploitAttackStrategy, FuzzerAttackStrategy, CustomHttpAttackStrategy

# Configure logging
logger = logging.getLogger("api_endpoints")

# Create router
router = APIRouter()

# Request/Response models
class StatusResponse(BaseModel):
    status: str
    version: Dict[str, str] = {}
    connected: bool

class ModuleListRequest(BaseModel):
    module_type: str = Field(default="exploits", description="Type of module to list")
    limit: int = Field(default=10, description="Maximum number of modules to return")

class ScanRequest(BaseModel):
    target: str = Field(..., description="Target host to scan")
    ports: str = Field(default="80,443,22,21", description="Comma-separated list of ports to scan")
    
    @validator('target')
    def validate_target(cls, v):
        if not v:
            raise ValueError("Target host cannot be empty")
        return v

class ModuleInfoRequest(BaseModel):
    module_type: str = Field(..., description="Type of module")
    module_name: str = Field(..., description="Name of the module")

# Health endpoint
@router.get("/health", response_model=StatusResponse, tags=["system"])
async def health():
    """Check the API and Metasploit connection status"""
    try:
        # Try to get version info from Metasploit
        client = msf_manager.get_client()
        version = client.core.version
        
        return {
            "status": "ok",
            "version": version,
            "connected": msf_manager.connected
        }
    except ConnectionError as e:
        logger.error(f"Health check failed: {str(e)}")
        return {
            "status": "error",
            "version": {},
            "connected": False
        }
    except Exception as e:
        logger.error(f"Unexpected error in health check: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

# Module listing endpoint
@router.get("/modules/{module_type}", tags=["modules"])
async def list_modules(
    module_type: str = Path(..., description="Type of module to list"),
    limit: int = Query(10, description="Maximum number of modules to return")
):
    """List available modules of the specified type"""
    try:
        modules = scanner_service.get_available_modules(module_type=module_type, limit=limit)
        return {
            "module_type": module_type,
            "limit": limit,
            "count": len(modules),
            "modules": modules
        }
    except Exception as e:
        logger.error(f"Error listing modules: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error listing modules: {str(e)}")

# Module info endpoint
@router.get("/modules/{module_type}/{module_name}", tags=["modules"])
async def get_module_info(
    module_type: str = Path(..., description="Type of module"),
    module_name: str = Path(..., description="Name of the module")
):
    """Get detailed information about a specific module"""
    try:
        info = scanner_service.get_module_info(module_type=module_type, module_name=module_name)
        return info
    except Exception as e:
        logger.error(f"Error getting module info: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting module info: {str(e)}")

# Port scanning endpoint
@router.post("/scan", tags=["scanning"])
async def scan_target(scan_request: ScanRequest):
    """Scan a target host for open ports"""
    try:
        result = scanner_service.run_port_scan(
            target_host=scan_request.target,
            ports=scan_request.ports
        )
        return result
    except Exception as e:
        logger.error(f"Error running port scan: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error running port scan: {str(e)}")

# Metasploit version endpoint
@router.get("/version", tags=["system"])
async def get_version():
    """Get Metasploit version information"""
    try:
        version = scanner_service.get_metasploit_version()
        return version
    except ConnectionError as e:
        logger.error(f"Connection error: {str(e)}")
        raise HTTPException(status_code=503, detail="Metasploit connection unavailable")
    except Exception as e:
        logger.error(f"Error getting version: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting version: {str(e)}")

# New Attack Execution Endpoint
@router.post("/attack/execute", response_model=AttackPlanExecutionReport, tags=["attack"])
async def execute_attack_plan(attack_plan: AttackPlan):
    """
    Receives an attack plan, executes it using the AttackOrchestrate service,
    and returns the execution report.
    """
    logger.info(f"Received attack plan: {attack_plan.plan_id} for target: {attack_plan.target_info}")
    try:
        # 1. Create and configure AttackStrategyFactory
        strategy_factory = AttackStrategyFactory()
        # These tool names must match 'tool_to_use' in AttackStep
        strategy_factory.register_strategy("metasploit", MetasploitAttackStrategy)
        strategy_factory.register_strategy("fuzzer", FuzzerAttackStrategy)
        strategy_factory.register_strategy("custom_http", CustomHttpAttackStrategy)
        # Add other strategies as needed

        # 2. Create AttackOrchestrate instance
        attack_orchestrator = AttackOrchestrate(strategy_factory=strategy_factory)

        # 3. Execute the plan
        logger.info(f"Executing attack plan {attack_plan.plan_id}...")
        report = attack_orchestrator.execute_plan(plan=attack_plan)
        logger.info(f"Attack plan {attack_plan.plan_id} execution finished. Status: {report.overall_status}")
        
        return report

    except ValueError as ve:
        logger.error(f"ValueError during attack execution for plan {attack_plan.plan_id}: {str(ve)}")
        raise HTTPException(status_code=400, detail=str(ve)) # e.g., "No strategy registered for tool"
    except ConnectionError as ce: # Assuming msf_manager could be used by strategies
        logger.error(f"Metasploit connection error during attack plan {attack_plan.plan_id}: {str(ce)}")
        raise HTTPException(status_code=503, detail=f"Metasploit connection error: {str(ce)}")
    except Exception as e:
        logger.error(f"Unexpected error during attack execution for plan {attack_plan.plan_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}") 