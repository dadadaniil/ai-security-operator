import time
import logging
from typing import Dict, List, Any, Optional
from enum import Enum

from core.msf_manager import msf_manager
from .attack_orchestrate import AttackOrchestrate
from core.config import settings


logger = logging.getLogger("scanner_service")

class ScannerService:
    """Service for scanning operations using Metasploit"""
    
    def __init__(self):
        self.timeout = settings.DEFAULT_TIMEOUT
    
    def get_available_modules(self, module_type: str = 'exploits', limit: int = 10) -> List[str]:
        """Get a list of available modules of the specified type"""
        logger.info(f"Listing {module_type} modules (limit: {limit})")
        
        try:
            client = msf_manager.get_client()
            modules = []
            
            count = 0
            for module in getattr(client.modules, module_type):
                modules.append(module)
                count += 1
                if limit and count >= limit:
                    break
            
            logger.info(f"Found {len(modules)} {module_type} modules")
            return modules
            
        except Exception as e:
            logger.error(f"Error listing {module_type} modules: {str(e)}")
            raise
    
    def get_module_info(self, module_type: str, module_name: str) -> Dict[str, Any]:
        """Get detailed information about a specific module"""
        logger.info(f"Getting info for {module_type} module: {module_name}")
        
        try:
            client = msf_manager.get_client()
            module = client.modules.use(module_type, module_name)
            
            
            info = {
                'name': module_name,
                'description': module.description,
                'options': module.options,
                'required': module.required,
                'missing_required': module.missing_required
            }
            
            
            if hasattr(module, 'targets') and module.targets:
                info['targets'] = module.targets
                info['default_target'] = module.default_target
            
            
            if hasattr(module, 'targetpayloads'):
                info['compatible_payloads'] = module.targetpayloads()
            
            return info
            
        except Exception as e:
            logger.error(f"Error getting info for {module_type} module {module_name}: {str(e)}")
            raise
    
    def run_port_scan(self, target_host: str, ports: str = '80,443,22,21') -> Dict[str, Any]:
        """Run a port scan against a target host"""
        logger.info(f"Starting port scan against {target_host} on ports {ports}")
        
        try:
            client = msf_manager.get_client()
            
            
            scanner = client.modules.use('auxiliary', 'scanner/portscan/tcp')
            scanner['RHOSTS'] = target_host
            scanner['PORTS'] = ports
            
            
            logger.info(f"Executing port scanner for {target_host}:{ports}")
            job_details = scanner.execute()
            
            job_id = None
            if isinstance(job_details, dict) and 'job_id' in job_details:
                job_id = job_details.get('job_id')

            if not job_id:
                error_message = "Failed to start Metasploit port scan job or no job ID returned."
                if isinstance(job_details, dict):
                    if 'error' in job_details and job_details['error']:
                         error_message = f"Metasploit error: {job_details.get('error_string', job_details.get('error_message', 'Unknown MSF error'))}"
                elif job_details is None: 
                    error_message = "Metasploit port scan module execution returned no details (None)."

                logger.error(f"{error_message} Raw execution result: {job_details}")
                return {
                    "status": "error",
                    "message": error_message,
                    "target": target_host,
                    "ports": ports,
                    "results": [],
                    "job_id": None
                }
            
            logger.info(f"Port scan job started with ID: {job_id} for target {target_host}")

            
            start_time = time.time()
            job_timed_out = False
            while str(job_id) in client.jobs.list:
                if time.time() - start_time > self.timeout:
                    logger.warning(f"Port scan job {job_id} for {target_host} timed out after {self.timeout} seconds.")
                    try:
                        client.jobs.stop(str(job_id))
                        logger.info(f"Attempted to stop timed-out job {job_id}.")
                    except Exception as e_stop:
                        logger.error(f"Error stopping job {job_id}: {str(e_stop)}")
                    job_timed_out = True
                    break
                time.sleep(2) 

            if job_timed_out:
                return {
                    "status": "error",
                    "message": f"Port scan timed out for job {job_id}",
                    "target": target_host,
                    "ports": ports,
                    "results": [],
                    "job_id": job_id
                }

            logger.info(f"Port scan job {job_id} for {target_host} completed or is no longer listed.")

            
            open_ports_info = []
            scanned_port_list = []
            if ports:
                scanned_port_list = [int(p.strip()) for p in ports.split(',') if p.strip().isdigit()]
            
            
            
            
            
            
            logger.info(f"Querying Metasploit DB for services on host: {target_host}, ports: {scanned_port_list}")
            
            
            rpc_call_options = {}
            rpc_call_options['hosts'] = [target_host] 
            if scanned_port_list:
                rpc_call_options['ports'] = scanned_port_list
            

            
            
            
            db_services_data = client.call('db.services', [rpc_call_options])
            
            if db_services_data and isinstance(db_services_data, dict) and 'services' in db_services_data:
                actual_services_list = db_services_data['services']
                for service in actual_services_list:
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    

                    open_ports_info.append({
                        "port": service.get('port'),
                        "proto": service.get('proto'),
                        "state": service.get('state'), 
                        "name": service.get('name'),
                        "info": service.get('info')
                    })
            elif isinstance(db_services_data, list): 
                logger.warning("db.services call returned a list directly, processing as such.")
                for service in db_services_data: 
                     if service.get('host') == target_host and (not scanned_port_list or service.get('port') in scanned_port_list):
                        open_ports_info.append({
                            "port": service.get('port'),
                            "proto": service.get('proto'),
                            "state": service.get('state'),
                            "name": service.get('name'),
                            "info": service.get('info')
                        })
            else:
                
                logger.warning(f"No services found in DB for {target_host} or unexpected return format: {type(db_services_data)}. Data: {db_services_data}")

            logger.info(f"Found {len(open_ports_info)} relevant services for {target_host} on scanned ports {ports}.")

            
            if not open_ports_info and job_id is not None:
                logger.info(f"Scan completed for {target_host} (job ID: {job_id}) but no services found/reported. Adding placeholder data.")
                open_ports_info.append({
                    "port": 0, 
                    "proto": "n/a",
                    "state": "placeholder",
                    "name": "no_services_found_or_reported",
                    "info": "Scan completed, but no open ports matching the criteria were reported by Metasploit or found in the database."
                })

            return {
                "status": "completed",
                "target": target_host,
                "ports": ports,
                "results": open_ports_info,
                "job_id": job_id 
            }

        except Exception as e:
            logger.error(f"Error running port scan against {target_host}: {str(e)}", exc_info=True)
            
            
            current_job_id = None
            if 'job_id' in locals() and job_id is not None: 
                 current_job_id = job_id
            return {
                "status": "error",
                "message": f"An unexpected error occurred: {str(e)}",
                "target": target_host,
                "ports": ports,
                "results": [],
                "job_id": current_job_id
            }

    def get_metasploit_version(self) -> Dict[str, str]:
        """Get Metasploit version information"""
        logger.info("Getting Metasploit version info")
        
        try:
            client = msf_manager.get_client()
            version = client.core.version
            return version
        except Exception as e:
            logger.error(f"Error getting Metasploit version: {str(e)}")
            raise


scanner_service = ScannerService() 